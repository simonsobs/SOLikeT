r"""
.. module:: cmbonly

:Synopsis: CMB-only likelihood for TTTEEE CMB power spectra for Simons Observatory
:Authors: Hidde T. Jense.

This is a likelihood for the products generated by the foreground marginalizer.
"""
import os
import numpy as np
from typing import Optional, Tuple
from ..ps import BinnedPSLikelihood


class CMBonly(BinnedPSLikelihood):
    """
    Likelihood for SO foreground-marginalized (cmb-only).

    Possible settings for the likelihood:

    * ``data_folder`` and ``data_filename`` The (path to the) sacc file you want to load.
    * ``ell_cuts`` A dictionary of ``xy: [min, max]`` for ell cuts on probes (e.g. ``"tt"
    : [500,3000]`` to only use the TT data between l = 500 and l = 3000).
    * ``lmax_theory`` If provided, the likelihood will request data up to at least this
    value from the theory code.

    Author: Hidde T. Jense
    """
    file_base_name: str = "so_cmb"

    data_filename: str = "so_simu_cmb_sacc.fits"
    data_folder: str = "SOCMBonly"
    ell_cuts: dict = {}
    lmax_theory: Optional[int] = None

    def initialize(self):
        if self.packages_path is None:
            self.data_folder = os.path.join(
                os.path.dirname(os.path.realpath(__file__)),
                "data")
        else:
            from cobaya.conventions import data_path
            self.data_folder = os.path.join(
                self.packages_path,
                data_path,
                self.data_folder)

        import sacc
        self.datapath = os.path.join(self.data_folder, self.data_filename)
        self.log.debug(f"Searching for data in {self.datapath}.")

        self.sacc = sacc.Sacc.load_fits(self.datapath)

        self.log.debug(f"File found, loading data from {self.datapath}.")

        pol_dt = {"t": "0", "e": "e", "b": "b"}

        self.ell_cuts = self.ell_cuts or {}
        self.lmax_theory = self.lmax_theory or -1

        self.spec_meta = []
        self.cull = []
        idx_max = 0

        for pol in ["TT", "TE", "EE"]:
            p1, p2 = pol.lower()
            t1, t2 = pol_dt[p1], pol_dt[p2]
            dt = f"cl_{t1}{t2}"

            tracers = self.sacc.get_tracer_combinations(dt)

            for tr1, tr2 in tracers:
                lmin, lmax = self.ell_cuts.get(pol, (-np.inf, np.inf))
                ls, mu, ind = self.sacc.get_ell_cl(dt, tr1, tr2,
                                                    return_ind=True)
                mask = np.logical_and(ls >= lmin, ls <= lmax)

                if not np.all(mask):
                    self.log.debug(
                        f"Cutting {pol} data to the range [{lmin}-{lmax}]."
                    )
                    self.cull.append(ind[~mask])

                window = self.sacc.get_bandpower_windows(ind[mask])

                self.spec_meta.append({
                    "data_type": dt,
                    "tracer1": tr1,
                    "tracer2": tr2,
                    "pol": pol.lower(),
                    "ell": ls[mask],
                    "spec": mu[mask],
                    "idx": ind[mask],
                    "window": window
                })

                idx_max = max(idx_max, max(ind))
                self.lmax_theory = max(self.lmax_theory,
                                       int(window.values.max()) + 1)

        self.ell_vec = np.zeros((idx_max + 1,))
        self.data_vec = np.zeros((idx_max + 1,))
        for m in self.spec_meta:
            self.ell_vec[m["idx"]] = m["ell"]
            self.data_vec[m["idx"]] = m["spec"]

        self.cov = self.sacc.covariance.covmat
        for culls in self.cull:
            self.cov[culls, :] = 0.0
            self.cov[:, culls] = 0.0
            self.cov[culls, culls] = 1e10

        self.inv_cov = np.linalg.inv(self.cov)
        self.logp_const = np.log(2.0 * np.pi) * -0.5 * len(self.data_vec)
        self.logp_const -= 0.5 * np.linalg.slogdet(self.cov)[1]

        self.log.debug(f"log(P) = {self.logp_const}")
        self.log.debug(f"len(data vec) = {len(self.data_vec)}")

    def get_requirements(self):
        return dict(Cl={
            k: self.lmax_theory + 1 for k in ["TT", "TE", "EE"]
        })

    def _get_data(self) -> Tuple[np.ndarray, np.ndarray]:
        return self.ell_vec, self.data_vec

    def _get_theory(self, **param_values):
        cl_theory = self.provider.get_Cl(ell_factor=True)
        cl_vec = np.zeros_like(self.data_vec)

        for m in self.spec_meta:
            idx = m["idx"]
            win = m["window"].weight.T
            ls = m["window"].values
            pol = m["pol"]

            cl_vec[idx] = win @ cl_theory[pol][ls]

        return cl_vec

    def chi_square(self, binned_theory):
        _, y = self._get_data()
        delta = binned_theory - y
        chisquare = delta @ self.inv_cov @ delta

        self.log.debug(f"Chisqr = {chisquare:.3f}")
        return chisquare

    def loglike(self, binned_theory):
        logp = -0.5 * self.chi_square(binned_theory)
        return self.logp_const + logp

    def logp(self, **param_values):
        binned_theory = self._get_theory(**param_values)
        return self.loglike(binned_theory)
